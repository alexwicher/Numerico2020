# -*- coding: utf-8 -*-
"""Parcial1_Numérico.ipynb

Automatically generated by Colaboratory.
"""

# Ejercicio 1 - serie_seno

import math as mt
from matplotlib import pyplot as plt


def serie_seno(x):
    terminos_taylor_sen = []
    t = 0
    valores_de_taylor = 0

    for t in range(5):
        valores_de_taylor += ((-1) ** t / mt.factorial(2 * t + 1)) * x ** (2 * t + 1)
        terminos_taylor_sen.append(valores_de_taylor)

    return terminos_taylor_sen


terminos_sin_5 = serie_seno(5)
print(f'segundo: terminos_sin_5={terminos_sin_5}')


# Exercise 2 - plot

# Hago esta funcion auxiliar para poder definir el eje x
def aux_interval(intervalo, distancia):
    # Defino intervalo [a,b]
    a, b = intervalo
    # Agrego ya como resultado al primer valor que nos da el  q intervalo (a)
    res = [a]
    while a <= b:
        # Voy haciendo que a sea sumado por la distancia ( en el ejercicio es 0.0.1) hasta llegar a b
        a += distancia
        # Guardo el valor
        res.append(a)
    # Devuelvo la lista 
    return res


def grafico_de_f(I, fun):
    x = aux_interval(I, 0.01)
    y = [fun(a) for a in x]
    plt.plot(x, y)
    ## Grafico una funcion f(x) = 0 para poder ver mis raíces, y por lo que se ve que algunas de ellas se podrían encontrar entre 3 y 5
    plt.plot(x, [0 for c in x])
    plt.show()


grafico_de_f((0, 6.4), lambda x: serie_seno(x)[-1])


# Ejercicio 3 - Bisección

# Función auxiliar para imprimir los valores de bisección

def show_results(hx, hf):
    print(f'El algoritmo corrio unas {len(hx)} interacciones')
    print(f'Los resultandos finales de x = {hx[-1]:.2f} y los f(x) = {hf[-1]:.2f}')


def rbisec(fun, I, err, mit):
    a, b = I
    hm, hf = [], []

    for _ in range(mit):
        #  Obtengo el punto medio
        m = (a + b) / 2
        f = fun(m)

        #  Guardo los resultados parciales
        hm.append(m);
        hf.append(f)

        #  Chequeo el resultado usando el absoluto del error
        if abs(f) < err:
            break

        #  Busco el nuevo intervalo
        if fun(a) * f < 0:
            b = m
        elif fun(b) * f < 0:
            a = m
        elif fun(a) * fun(b) > 0:
            break

    return hm, hf


hx, hf = (rbisec(lambda x: serie_seno(x)[-1], (3, 5), 1e-5, 100))

show_results(hx, hf)

hx, hf = rbisec(lambda x: serie_seno(x)[-1], (4, 5), 1e-5, 100)

show_results(hx, hf)


## Después de correr rbisec, nos damos cuenta que en 3.15 esta la primera raíz positiva y la segunda está en 4.96

## Ejercicio 4 

def rsteffensen(fun, x0, err, mit):
    hx, hf = [], []
    x = x0
    for _ in range(mit):
        f = fun(x)

        hx.append(x)
        hf.append(f)

        if abs(f) < err:
            break

        # Creo el divisor como una constante para una mejor lectura
        divisor = fun(x + f) - f

        x = x - ((f ** 2) / divisor)
    return hx, hf


hx, hf = rsteffensen(lambda x: serie_seno(x)[-1], 3, 1e-5, 100)
show_results(hx, hf)


# Ejercicio 5
def buscar_raices(x0):
    hx, hf = rsteffensen(lambda x: serie_seno(x)[-1], x0, 1e-5, 100)
    print(f'Resultado método rsteffensen con x0 igual {x0} :')
    show_results(hx, hf)


buscar_raices(3)
buscar_raices(6)
buscar_raices(4.5)

"""  
Como vemos en los resultados de las funciones, podemos ver que con un punto inicial x0 = 3 y con punto inicial x0 = 6 encuentra las raíces 
, pero cuando usamos el valor x0 como 4.5 no encuentra la raíz.
"""
